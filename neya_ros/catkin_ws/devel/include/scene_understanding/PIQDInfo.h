// Generated by gencpp from file scene_understanding/PIQDInfo.msg
// DO NOT EDIT!


#ifndef SCENE_UNDERSTANDING_MESSAGE_PIQDINFO_H
#define SCENE_UNDERSTANDING_MESSAGE_PIQDINFO_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace scene_understanding
{
template <class ContainerAllocator>
struct PIQDInfo_
{
  typedef PIQDInfo_<ContainerAllocator> Type;

  PIQDInfo_()
    : stamp()
    , target(0.0)
    , current(0.0)
    , error(0.0)
    , proportionalTerm(0.0)
    , integralTerm(0.0)
    , integralTermLowerLimit(0.0)
    , integralTermUpperLimit(0.0)
    , quadraticTerm(0.0)
    , derivativeTerm(0.0)
    , feedForwardTerm(0.0)
    , piqdOutput(0.0)
    , controlOutput(0.0)
    , saturatedControlOutput(0.0)
    , timeDifference(0.0)  {
    }
  PIQDInfo_(const ContainerAllocator& _alloc)
    : stamp()
    , target(0.0)
    , current(0.0)
    , error(0.0)
    , proportionalTerm(0.0)
    , integralTerm(0.0)
    , integralTermLowerLimit(0.0)
    , integralTermUpperLimit(0.0)
    , quadraticTerm(0.0)
    , derivativeTerm(0.0)
    , feedForwardTerm(0.0)
    , piqdOutput(0.0)
    , controlOutput(0.0)
    , saturatedControlOutput(0.0)
    , timeDifference(0.0)  {
  (void)_alloc;
    }



   typedef ros::Time _stamp_type;
  _stamp_type stamp;

   typedef double _target_type;
  _target_type target;

   typedef double _current_type;
  _current_type current;

   typedef double _error_type;
  _error_type error;

   typedef double _proportionalTerm_type;
  _proportionalTerm_type proportionalTerm;

   typedef double _integralTerm_type;
  _integralTerm_type integralTerm;

   typedef double _integralTermLowerLimit_type;
  _integralTermLowerLimit_type integralTermLowerLimit;

   typedef double _integralTermUpperLimit_type;
  _integralTermUpperLimit_type integralTermUpperLimit;

   typedef double _quadraticTerm_type;
  _quadraticTerm_type quadraticTerm;

   typedef double _derivativeTerm_type;
  _derivativeTerm_type derivativeTerm;

   typedef double _feedForwardTerm_type;
  _feedForwardTerm_type feedForwardTerm;

   typedef double _piqdOutput_type;
  _piqdOutput_type piqdOutput;

   typedef double _controlOutput_type;
  _controlOutput_type controlOutput;

   typedef double _saturatedControlOutput_type;
  _saturatedControlOutput_type saturatedControlOutput;

   typedef double _timeDifference_type;
  _timeDifference_type timeDifference;





  typedef boost::shared_ptr< ::scene_understanding::PIQDInfo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::scene_understanding::PIQDInfo_<ContainerAllocator> const> ConstPtr;

}; // struct PIQDInfo_

typedef ::scene_understanding::PIQDInfo_<std::allocator<void> > PIQDInfo;

typedef boost::shared_ptr< ::scene_understanding::PIQDInfo > PIQDInfoPtr;
typedef boost::shared_ptr< ::scene_understanding::PIQDInfo const> PIQDInfoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::scene_understanding::PIQDInfo_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::scene_understanding::PIQDInfo_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::scene_understanding::PIQDInfo_<ContainerAllocator1> & lhs, const ::scene_understanding::PIQDInfo_<ContainerAllocator2> & rhs)
{
  return lhs.stamp == rhs.stamp &&
    lhs.target == rhs.target &&
    lhs.current == rhs.current &&
    lhs.error == rhs.error &&
    lhs.proportionalTerm == rhs.proportionalTerm &&
    lhs.integralTerm == rhs.integralTerm &&
    lhs.integralTermLowerLimit == rhs.integralTermLowerLimit &&
    lhs.integralTermUpperLimit == rhs.integralTermUpperLimit &&
    lhs.quadraticTerm == rhs.quadraticTerm &&
    lhs.derivativeTerm == rhs.derivativeTerm &&
    lhs.feedForwardTerm == rhs.feedForwardTerm &&
    lhs.piqdOutput == rhs.piqdOutput &&
    lhs.controlOutput == rhs.controlOutput &&
    lhs.saturatedControlOutput == rhs.saturatedControlOutput &&
    lhs.timeDifference == rhs.timeDifference;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::scene_understanding::PIQDInfo_<ContainerAllocator1> & lhs, const ::scene_understanding::PIQDInfo_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace scene_understanding

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::scene_understanding::PIQDInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::scene_understanding::PIQDInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::scene_understanding::PIQDInfo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::scene_understanding::PIQDInfo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::scene_understanding::PIQDInfo_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::scene_understanding::PIQDInfo_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::scene_understanding::PIQDInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "240bec481b74c3ece1f9f0cf6d2d3d49";
  }

  static const char* value(const ::scene_understanding::PIQDInfo_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x240bec481b74c3ecULL;
  static const uint64_t static_value2 = 0xe1f9f0cf6d2d3d49ULL;
};

template<class ContainerAllocator>
struct DataType< ::scene_understanding::PIQDInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "scene_understanding/PIQDInfo";
  }

  static const char* value(const ::scene_understanding::PIQDInfo_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::scene_understanding::PIQDInfo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "time stamp\n"
"\n"
"float64 target\n"
"float64 current\n"
"float64 error\n"
"float64 proportionalTerm\n"
"float64 integralTerm\n"
"float64 integralTermLowerLimit\n"
"float64 integralTermUpperLimit\n"
"float64 quadraticTerm\n"
"float64 derivativeTerm\n"
"float64 feedForwardTerm\n"
"float64 piqdOutput\n"
"float64 controlOutput\n"
"float64 saturatedControlOutput\n"
"float64 timeDifference\n"
;
  }

  static const char* value(const ::scene_understanding::PIQDInfo_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::scene_understanding::PIQDInfo_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.stamp);
      stream.next(m.target);
      stream.next(m.current);
      stream.next(m.error);
      stream.next(m.proportionalTerm);
      stream.next(m.integralTerm);
      stream.next(m.integralTermLowerLimit);
      stream.next(m.integralTermUpperLimit);
      stream.next(m.quadraticTerm);
      stream.next(m.derivativeTerm);
      stream.next(m.feedForwardTerm);
      stream.next(m.piqdOutput);
      stream.next(m.controlOutput);
      stream.next(m.saturatedControlOutput);
      stream.next(m.timeDifference);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct PIQDInfo_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::scene_understanding::PIQDInfo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::scene_understanding::PIQDInfo_<ContainerAllocator>& v)
  {
    s << indent << "stamp: ";
    Printer<ros::Time>::stream(s, indent + "  ", v.stamp);
    s << indent << "target: ";
    Printer<double>::stream(s, indent + "  ", v.target);
    s << indent << "current: ";
    Printer<double>::stream(s, indent + "  ", v.current);
    s << indent << "error: ";
    Printer<double>::stream(s, indent + "  ", v.error);
    s << indent << "proportionalTerm: ";
    Printer<double>::stream(s, indent + "  ", v.proportionalTerm);
    s << indent << "integralTerm: ";
    Printer<double>::stream(s, indent + "  ", v.integralTerm);
    s << indent << "integralTermLowerLimit: ";
    Printer<double>::stream(s, indent + "  ", v.integralTermLowerLimit);
    s << indent << "integralTermUpperLimit: ";
    Printer<double>::stream(s, indent + "  ", v.integralTermUpperLimit);
    s << indent << "quadraticTerm: ";
    Printer<double>::stream(s, indent + "  ", v.quadraticTerm);
    s << indent << "derivativeTerm: ";
    Printer<double>::stream(s, indent + "  ", v.derivativeTerm);
    s << indent << "feedForwardTerm: ";
    Printer<double>::stream(s, indent + "  ", v.feedForwardTerm);
    s << indent << "piqdOutput: ";
    Printer<double>::stream(s, indent + "  ", v.piqdOutput);
    s << indent << "controlOutput: ";
    Printer<double>::stream(s, indent + "  ", v.controlOutput);
    s << indent << "saturatedControlOutput: ";
    Printer<double>::stream(s, indent + "  ", v.saturatedControlOutput);
    s << indent << "timeDifference: ";
    Printer<double>::stream(s, indent + "  ", v.timeDifference);
  }
};

} // namespace message_operations
} // namespace ros

#endif // SCENE_UNDERSTANDING_MESSAGE_PIQDINFO_H
